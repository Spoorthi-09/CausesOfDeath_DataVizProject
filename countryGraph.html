<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Country Graph</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        .tooltip {
            position: absolute;
            background-color: #fff;
            color: #333;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 5px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }


        .container {
            display: flex;
        }

        #checkbox-container {
            margin-left: 50px;
            /* Adjust spacing between the chart and checkboxes */
        }
        

        #plot,
        #stacked-chart {
            margin: 0 auto;
            /* This centers the elements */
            display: block;
            /* Ensures it's displayed as a block element */
            text-align: center;
            /* Aligns the contents to the center */
            max-width: 800px;
            /* Adjust the maximum width as needed */
            /* Add any other styling you require */
        }
    </style>
</head>

<body>
    <h1>Country Information</h1>
    <div id="country-info">
        <p id="country-name"></p>
    </div>

    <div id="plot"></div>
    <div class="container">
        <div id="stacked-chart"></div>
        <div id="checkbox-container"></div>
    </div>


    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const countryName = urlParams.get("country");

        const countryNameElement = document.getElementById("country-name");
        if (countryName) {
            countryNameElement.textContent = `GDP and Total Deaths in ${countryName}`;
        } else {
            countryNameElement.textContent = "No country selected.";
        }

        d3.csv("deaths_gdp_obesity_sorted.csv").then(function (data) {
            const countryData = data.filter(d => d["Country/Territory"] === countryName);

            const years = countryData.map(d => +d.Year);
            const totalDeaths = countryData.map(d => +d.total_deaths.replace(/,/g, ''));
            const gdpValues = countryData.map(d => +d.Value.replace(/,/g, ''));


            const margin = { top: 50, right: 50, bottom: 50, left: 50 };
            const width = 800 - margin.left - margin.right;
            const height = 600 - margin.top - margin.bottom;

            const svg = d3.select("#plot")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const xScale = d3.scaleLinear()
                .domain(d3.extent(years))
                .range([0, width]);

            const y1Scale = d3.scaleLinear()
                .domain([0, d3.max(totalDeaths)])
                .range([height, 0]);

            const y2Scale = d3.scaleLinear()
                .domain([0, d3.max(gdpValues)])
                .range([height, 0]);

            const xAxis = d3.axisBottom(xScale).tickFormat(d3.format("d"));
            const y1Axis = d3.axisLeft(y1Scale).tickFormat(d3.format(".2s"));
            const y2Axis = d3.axisRight(y2Scale).tickFormat(d3.format(".2s"));;

            svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(xAxis);

            svg.append("g")
                .call(y1Axis)
                .attr("class", "y-axis1");

            svg.append("g")
                .attr("transform", `translate(${width},0)`)
                .call(y2Axis)
                .attr("class", "y-axis2");

            const line1 = d3.line()
                .x((d, i) => xScale(years[i]))
                .y(d => y1Scale(d))
                .curve(d3.curveLinear);

            const line2 = d3.line()
                .x((d, i) => xScale(years[i]))
                .y(d => y2Scale(d))
                .curve(d3.curveLinear);

            svg.append("path")
                .datum(totalDeaths)
                .attr("fill", "none")
                .attr("stroke", "steelblue")
                .attr("stroke-width", 2)
                .attr("d", line1);

            svg.append("path")
                .datum(gdpValues)
                .attr("fill", "none")
                .attr("stroke", "red")
                .attr("stroke-width", 2)
                .attr("d", line2);

            // Apply transition to both lines
            svg.selectAll("path")
                .transition()
                .duration(2000)
                .attrTween("d", function (d) {
                    if (!d || !d.length) {
                        return; // If data is null or has no length, skip
                    }
                    const interpolate = d3.scaleLinear()
                        .domain([0, 1])
                        .rangeRound([1, d.length - 1]);
                    const currentPath = this;
                    return function (t) {
                        if (currentPath.getAttribute("stroke") === "steelblue") {
                            return line1(d.slice(0, interpolate(t)));
                        } else if (currentPath.getAttribute("stroke") === "red") {
                            return line2(d.slice(0, interpolate(t)));
                        }
                    };
                });

            // Append left y-axis label
            svg.append("text")
                .attr("class", "y-axis-label")
                .attr("text-anchor", "middle")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 10) // Adjust the horizontal position of the left y-axis label
                .text("Total Deaths (in millions)");

            // Append right y-axis label
            svg.append("text")
                .attr("class", "y-axis-label")
                .attr("text-anchor", "middle")
                .attr("transform", `translate(${width + 10 + margin.right / 2}, ${height / 2}) rotate(90)`) // Adjust the position of the right y-axis label
                .text("GDP (in millions)");

        }).catch(function (error) {
            console.log(error);
        });
    </script>
    <!-- 
<script>
    //Get the country name from the query parameter in the URL
    const urlParams = new URLSearchParams(window.location.search);
    const countryName = urlParams.get("country");

    //Display the country name on the page
    const countryNameElement = document.getElementById("country-name");
    if (countryName) {
        countryNameElement.textContent = `You clicked on: ${countryName}`;
    } else {
        countryNameElement.textContent = "No country selected.";
    }

    //Load the data from deaths_gdp_obesity_sorted.csv
    Plotly.d3.csv("deaths_gdp_obesity_sorted.csv", function(data) {
        //Filter the data for the selected country
        const countryData = data.filter(d => d["Country/Territory"] === countryName);

        //Extract years, total deaths, and GDP data
        const years = countryData.map(d => d.Year);
        const totalDeaths = countryData.map(d => d.total_deaths);
        const gdpValues = countryData.map(d => d.Value);

        //Define trace for total deaths
        const trace1 = {
            x: years,
            y: totalDeaths,
            mode: 'lines+markers',
            type: 'scatter',
            name: 'Total Deaths',
            yaxis: 'y1'
        };

        //Define trace for GDP
        const trace2 = {
            x: years,
            y: gdpValues,
            mode: 'lines+markers',
            type: 'scatter',
            name: 'GDP',
            yaxis: 'y2'
        };

        //Create data array with both traces
        const plotData = [trace1, trace2];

        //Define layout for the dual-axis plot
        const layout = {
            title: `GDP and Total Deaths in ${countryName}`,
            xaxis: {
                title: 'Year',
            },
            yaxis: {
                title: 'Total Deaths',
                side: 'left',
            },
            yaxis2: {
                title: 'GDP',
                side: 'right',
                overlaying: 'y',
            }
        };

        //Plot the data
        Plotly.newPlot('plot', plotData, layout);
    });
</script> -->
    <!-- <script>
        //Define custom hex color codes for each cause of death
        const customColors = [
            '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f',
            '#bcbd22', '#17becf', '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5', '#c49c94',
            '#f7b6d2', '#c7c7c7', '#dbdb8d', '#9edae5', '#393b79', '#5254a3', '#6b6ecf', '#9c9ede',
            '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#e7ba52', '#e7cb94', '#edc949', '#f0c17d'
        ];

        //Load the data from deaths.csv (modify the path to match your file structure)
        Plotly.d3.csv("deaths_gdp_obesity_sorted.csv", function(data) {
            //Filter the data for the selected country
            const countryData = data.filter(d => d["Country/Territory"] === countryName);

            //extract causes of death columns
            const causesOfDeathColumns = Object.keys(countryData[0]).slice(3, 33);

            //creating traces for each cause of death with custom colors
            const traces = causesOfDeathColumns.map((cause, index) => {
                return {
                    x: countryData.map(d => d.Year),
                    y: countryData.map(d => +d[cause]),
                    name: cause,
                    type: 'bar',
                    marker: { color: customColors[index] }, 
                };
            });

            //creating layout for the stacked bar chart
            const layout = {
                title: 'Causes of Death Over Time',
                xaxis: {
                    title: 'Year',
                },
                yaxis: {
                    title: 'Number of Deaths',
                },
                barmode: 'stack',
            };

            //ploting the stacked bar chart
            Plotly.newPlot('stacked-chart', traces, layout);
        });
    </script> -->

    <script>
        // Define custom hex color codes for each cause of death
        const customColors = [
            '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f',
            '#bcbd22', '#17becf', '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5', '#c49c94',
            '#f7b6d2', '#c7c7c7', '#dbdb8d', '#9edae5', '#393b79', '#5254a3', '#6b6ecf', '#9c9ede',
            '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#e7ba52', '#e7cb94'
        ];

        // Load the data from deaths.csv (modify the path to match your file structure)
        d3.csv("deaths_gdp_obesity_sorted.csv").then(function (data) {
            // Filter the data for the selected country
            const countryData = data.filter(d => d["Country/Territory"] === countryName);
            // console.log(countryData)

            // Extract causes of death columns
            const causesOfDeathColumns = Object.keys(countryData[0]).slice(3, 33);
            // console.log(causesOfDeathColumns)

            // Create SVG dimensions
            const margin = { top: 50, right: 50, bottom: 50, left: 50 };
            const width = 800 - margin.left - margin.right;
            const height = 600 - margin.top - margin.bottom;

            // Create SVG
            const svg = d3.select("#stacked-chart")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left}, ${margin.top})`);

            // Create tooltip
            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("opacity", 0)
                .style("position", "absolute")
                .style("background-color", "white")
                .style("border", "1px solid black")
                .style("padding", "5px")
                .style("pointer-events", "none") // Prevent tooltip blocking mouse events on bars
                .style("left", "0px") // Initial positioning
                .style("top", "0px")
                .style("transform", "translate(-50%, calc(100% - 10px))")
                .style("z-index", 999);

            const stackedData = d3.stack().keys(causesOfDeathColumns)(countryData);
            // console.log(stackedData)
            // Create scales for x and y axes
            const xScale = d3.scaleBand()
                .domain(countryData.map(d => d.Year))
                .range([0, width])
                .padding(0.1);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(stackedData, d => d3.max(d, d => d[1]))])
                .range([height, 0]);

            console.log(d3.max(stackedData, d => d3.max(d, d => d[1])))

            // Adjusting y-axis scale and ticks for millions
            const yAxis = d3.axisLeft(yScale)
                .tickFormat(d3.format(".2s")); // Format ticks in millions

            // Create color scale for different causes of death
            const color = d3.scaleOrdinal()
                .domain(causesOfDeathColumns)
                .range(customColors);

            const causeColorMap = {};
            causesOfDeathColumns.forEach((cause, index) => {
                causeColorMap[cause] = customColors[index % customColors.length];
            });

            // console.log(causeColorMap)



            //Add bars to the chart
            svg.selectAll("g")
                .data(stackedData)
                .join("g")
                .attr("fill", d => causeColorMap[d.key])
                .selectAll("rect")
                .data(d => d)
                .join("rect")
                .attr("x", (d, i) => xScale(countryData[i].Year))
                .attr("y", d => yScale(d[1]))
                .attr("height", d => yScale(d[0]) - yScale(d[1]))
                .attr("width", xScale.bandwidth())
                .on("mouseover", function (event, d) {
                    const disease = d3.select(this.parentNode).datum().key;
                    const deaths = d[1] - d[0];

                    // Get coordinates and dimensions of the hovered bar
                    const [x, y, width, height] = [event.pageX, event.pageY, this.getBBox().width, this.getBBox().height];

                    // Position tooltip relative to the bar
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", 0.9)
                        .style("left", `${x - width / 2}px`)
                        .style("top", `${y - height - 10}px`); // Offset to place it above the bar
                    // Set tooltip content
                    tooltip.html(`${disease}: ${deaths}`);
                })
                // Hide tooltip on mouseout
                .on("mouseout", function () {
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", 0);
                });

            // Add x-axis
            svg.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(xScale))
                .selectAll("text")
                .attr("transform", "rotate(-45)")
                .attr("text-anchor", "end")
                .attr("dy", "-0.5em")
                .attr("dx", "-0.8em");

            // Create y-axis
            svg.append("g")
                .call(yAxis)
                .append("text") // Label for y-axis
                .attr("class", "y-axis-label")
                .attr("text-anchor", "middle")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 20)
                .text("Total Deaths (in millions)");

            const checkboxContainer = d3.select("#checkbox-container");

            // Create checkboxes with color squares for each disease
            const checkboxes = checkboxContainer.selectAll("div")
                .data(causesOfDeathColumns)
                .enter()
                .append("div")
                .attr("class", "checkbox-group");

            checkboxes
                .append("input")
                .attr("type", "checkbox")
                .attr("class", "disease-checkbox")
                .attr("id", (d, i) => `checkbox-${i}`)
                .attr("value", d => d)
                .property("checked", true); // Initial checkbox state

            checkboxes
                .append("span")
                .style("display", "inline-block")
                .style("width", "10px")
                .style("height", "10px")
                .style("background-color", (d, i) => customColors[i])
                .style("margin-right", "5px");

            checkboxes
                .append("label")
                .attr("for", (d, i) => `checkbox-${i}`)
                .text(d => d);

                function clearChart() {
  svg.selectAll("*")
    .remove(); // Explicitly remove all elements
}

            // Function to update the chart based on checkbox status
            function updateChart() {

                clearChart();
                

                const selectedCauses = []; // Array to store selected causes

                // Check the status of each checkbox and collect selected causes
                d3.selectAll(".disease-checkbox").each(function () {
                    const cause = d3.select(this).property("value");
                    if (this.checked) {
                        selectedCauses.push(cause);
                    }
                });

                // Filter the data based on selected causes
                const filteredData = countryData.map(d => ({
                    Year: d.Year,
                    total_deaths: d.total_deaths,
                    ...selectedCauses.reduce((acc, cause) => {
                        acc[cause] = d[cause];
                        return acc;
                    }, {})
                }));

                console.log(filteredData);

                const stackedFilteredData = d3.stack().keys(selectedCauses)(filteredData);

                console.log(stackedFilteredData)

                // Update y-axis domain based on the filtered data
                const maxTotalDeaths = d3.max(filteredData, d => +d.total_deaths);
                yScale.domain([0, maxTotalDeaths]);
                // Update bars with new data
                const bars = svg.selectAll(".bars")
                    .data(stackedFilteredData, d => d.key);

                // bars.exit().remove(); // Remove bars not in the updated dataset

                bars.exit()
    .transition()
    .duration(500)
    .remove();

                // svg.selectAll('*').remove();

                bars.enter().append("g")
                    .attr("class", "bars")
                    .attr("fill", d => causeColorMap[d.key])
                    .merge(bars)
                    .selectAll("rect")
                    .data(d => d, (d, i) => `${d.key}-${i}`)
                    .join("rect")
                    .transition()
                    .duration(500)
                    .attr("x", (d, i) => xScale(filteredData[i].Year))
                    .attr("y", d => yScale(+d[1]))
                    .attr("height", d => yScale(+d[0]) - yScale(+d[1]))
                    .attr("width", xScale.bandwidth())
                    .attr("fill", d => causeColorMap[d.key]);

                    svg.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(xScale))
                .selectAll("text")
                .attr("transform", "rotate(-45)")
                .attr("text-anchor", "end")
                .attr("dy", "-0.5em")
                .attr("dx", "-0.8em");

            // Create y-axis
            svg.append("g")
                .call(yAxis)
                .append("text") // Label for y-axis
                .attr("class", "y-axis-label")
                .attr("text-anchor", "middle")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 20)
                .text("Total Deaths (in millions)");

                    
                // Update y-axis
                // svg.select(".y-axis")
                //     .transition()
                //     .duration(500)
                //     .call(yAxis);

                // // Update x-axis
                // svg.select(".x-axis")
                //     .transition()
                //     .duration(500)
                //     .call(d3.axisBottom(xScale)
                //         .tickFormat(d3.format(".0f"))
                //         .tickSizeOuter(0)
                //         .ticks(filteredData.length));
            }

            // Event listener for checkbox changes
            d3.selectAll(".disease-checkbox").on("change", updateChart);

        });
    </script>


</body>

</html>